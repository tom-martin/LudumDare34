{
  "name": "sanitize-filename",
  "version": "1.4.5",
  "description": "Sanitize a string for use as a filename",
  "main": "index.js",
  "scripts": {
    "test": "node test.js"
  },
  "repository": {
    "type": "git",
    "url": "git@github.com:parshap/node-sanitize-filename.git"
  },
  "keywords": [
    "file",
    "name",
    "filename",
    "sanitize",
    "validate",
    "escape"
  ],
  "author": {
    "name": "Parsha Pourkhomami"
  },
  "license": "WTFPL OR ISC",
  "devDependencies": {
    "mktemp": "^0.4.0",
    "tape": "^4.2.0"
  },
  "contributors": [
    {
      "name": "Parsha Pourkhomami",
      "email": "parshap@gmail.com"
    },
    {
      "name": "Joel Mukuthu",
      "email": "joelmukuthu@gmail.com"
    }
  ],
  "readme": "# sanitize-filename\n\n[![build\nstatus](https://secure.travis-ci.org/parshap/node-sanitize-filename.svg?branch=master)](http://travis-ci.org/parshap/node-sanitize-filename)\n\nSanitize a string to be safe for use as a filename by removing directory\npaths and invalid characters.\n\n## Example\n\n```js\nvar sanitize = require(\"sanitize-filename\");\n\n// Some string that may be unsafe or invalid as a filename\nvar UNSAFE_USER_INPUT = \"~/.\\u0000ssh/authorized_keys\";\n\n// Sanitize the string to be safe for use as a filename.\nvar filename = sanitize(UNSAFE_USER_INPUT);\n// -> \"~.sshauthorized_keys\"\n```\n\n## Details\n\n*sanitize-filename* works by searching the input string for the\nfollowing and removes them.\n\n * [Control characters][] (`0x00-0x1f` and `0x80-0x9f`)\n * [Reserved characters][] (`/` `?` `<` `>` `\\` `:` `*` `|` `\"`)\n * Unix reserved filenames (`.` and `..`)\n * Windows reserved filenames (`CON` `PRN` `AUX` `NUL` `COM1`\n   `COM2` `COM3` `COM4` `COM5` `COM6` `COM7` `COM8` `COM9`\n   `LPT1` `LPT2` `LPT3` `LPT4` `LPT5` `LPT6` `LPT7` `LPT8` and\n   `LPT9`)\n\n[control characters]: https://en.wikipedia.org/wiki/C0_and_C1_control_codes\n[reserved characters]: https://kb.acronis.com/content/39790\n\nThe return value is capped at [255 characters in length][255].\n\n[255]: http://unix.stackexchange.com/questions/32795/what-is-the-maximum-allowed-filename-and-folder-size-with-ecryptfs\n\nThis guarantees that the resulting string does not contain directory\npaths (no `/` or `\\` characters) and is a valid filename.\n\n### File Systems\n\nThe return value will be safe for use as a filename on modern Windows,\nOSX, and Unix file systems (`NTFS`, `ext`, etc.).\n\n[`FAT` 8.3 filenames][8.3] are not supported.\n\n[8.3]: https://en.wikipedia.org/wiki/8.3_filename\n\n#### Testing Your File System\n\nThe test program will attempt to use various strings (including the [Big\nList of Naughty Strings][blns]) to create files in the working\ndirectory. Run `npm test` to run tests against your file system.\n\n[blns]: https://github.com/minimaxir/big-list-of-naughty-strings\n\n### Non-unique Filenames\n\nNote that two unique inputs can result in the same return value. For\nexample:\n\n```js\nvar sanitize = require(\"sanitize-filename\");\nsanitize(\"file?\")\n// -> \"file\"\nsanitize (\"file*\")\n// -> \"file\"\n```\n\n### Empty String `\"\"` Return Value\n\nNote that the return value can be an empty string. For example:\n\n```js\nvar sanitize = require(\"sanitize-filename\");\nsanitize(\"..\")\n// -> \"\"\n\n```\n\n## API\n\n### `sanitize(filename, [options])`\n\nSanitize the input string `filename` by removing or replacing invalid\ncharacters. `options.replacement` can be a string to replace characters\nwith.\n\n## Installation\n\n```\nnpm install sanitize-filename\n```\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/parshap/node-sanitize-filename/issues"
  },
  "_id": "sanitize-filename@1.4.5",
  "dist": {
    "shasum": "32bbe6b4205d7128f76753dbdf15ecf108d85a56"
  },
  "_from": "sanitize-filename@1.4.5",
  "_resolved": "https://registry.npmjs.org/sanitize-filename/-/sanitize-filename-1.4.5.tgz"
}
